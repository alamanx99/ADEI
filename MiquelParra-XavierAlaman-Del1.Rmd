---
title: "USED CAR PRICES CASE STUDY"
subtitle: 'Deliverable I: Data Processing, Description, Validation and Profiling'
author: "Miquel Parra i Xavier Alaman"
date: \today
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
geometry: left=1.9cm,right=1.9cm,top=1.25cm,bottom=1.52cm
fontsize: 18pt
classoption: a4paper
editor_options: 
  chunk_output_type: inline
---

# R libraries imports, useful functions and data loading

In this first section we will load all required packages and libraries, declare additional functions, and load our data.

## Load required packages

```{r, message=FALSE, warning=FALSE, results='hide'}
options(contrasts=c("contr.treatment","contr.treatment"))

requiredPackages <- c("effects","FactoMineR","car", 
                      "factoextra","RColorBrewer","ggplot2","dplyr","ggmap",
                      "ggthemes","knitr","treemap")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(requiredPackages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
    library(x, character.only = TRUE)
  }
})

#verify they are loaded
search()
```

## Sample load

```{r, results='hide'}
# Clear plots
if(!is.null(dev.list())) dev.off()

# Clean workspace
rm(list=ls())

# Users file path
miquel_fp <- "C:/Users/Miquel/Documents/GitHub/ADEI/"
xavi_fp <- "~/Documents/FIB/ADEI/ADEI/"
filepath <- xavi_fp
filepath <-miquel_fp

# Set working directory
setwd(filepath)

# Load data from file
load(paste0(filepath,"MyOldCars-Raw.RData"))

# Index reset
row.names(df) <- NULL
```

## Useful functions

```{r}
#Mout <- which((df$tax < var_out$mouti)|(df$tax > var_out$mouts))

# Some useful functions
calcQ <- function(x) {
  s.x <- summary(x)
  iqr<-s.x[5]-s.x[2]
  list(souti=s.x[2]-3*iqr, mouti=s.x[2]-1.5*iqr, min=s.x[1], q1=s.x[2], q2=s.x[3], 
       q3=s.x[5], max=s.x[6], mouts=s.x[5]+1.5*iqr, souts=s.x[5]+3*iqr ) }

countNA <- function(x) {
  mis_x <- NULL
  for (j in 1:ncol(x)) {mis_x[j] <- sum(is.na(x[,j])) }
  mis_x <- as.data.frame(mis_x)
  rownames(mis_x) <- names(x)
  mis_i <- rep(0,nrow(x))
  for (j in 1:ncol(x)) {mis_i <- mis_i + as.numeric(is.na(x[,j])) }
  list(mis_col=mis_x,mis_ind=mis_i) }

countX <- function(x,X) {
  n_x <- NULL
  for (j in 1:ncol(x)) {n_x[j] <- sum(x[,j]==X) }
  n_x <- as.data.frame(n_x)
  rownames(n_x) <- names(x)
  nx_i <- rep(0,nrow(x))
  for (j in 1:ncol(x)) {nx_i <- nx_i + as.numeric(x[,j]==X) }
  list(nx_col=n_x,nx_ind=nx_i) }
```

# Data Description

During this project we will be working with a subset of the pre-treated original dataset ["Uk used car dataset"](https://www.kaggle.com/adityadesai13/used-car-dataset-ford-and-mercedes). A sample of 5000 cars has been randomly selected from Mercedes, BMW, Volkswagen and Audi manufacturers and stored into a RData file ***MyOldCars-Raw.RData***.

## Original variables description

-   **model:** Car model.
-   **year:** Car registration year.
-   **price:** Car price in £.
-   **transmission:** Type of transmission ["Manual", "Automatic", "Semi-Auto"].
-   **mileage:** Distance used, accumulated miles.
-   **fuelType:** Type of engine fuel ["Petrol", "Diesel", "Hybrid", "Other" ].
-   **tax:** Applied road tax.
-   **mpg:** Miles per gallon.
-   **engineSize:** Engine size in liters. The cars with engine size 0 are in fact electric cars, nevertheless Mercedes C class, and other given cars are not electric cars,so data imputation is required.
-   **manufacturer:** Car manufacturer ["Audi", "BMW", "Mercedes", "VW"].

```{r}
summary(df)
head(df, 3)
```

# Univariate Descriptive Analysis

In this step of the process original numeric variables corresponding to qualitative concepts have to be converted to factors. New factors grouping original levels will be considered very positively.

Additionally original numeric variables corresponding to real quantitative concepts are kept as numeric but additional factors should also be created as a discretization of each numeric variable.

For each variable we will perform the necessary transformations and also visualize its distribution.

## Numeric variables

### years_sell

From **year** we can create a new variable called **years_sell**. It will contain the same information as **year** but it will give more valuable information for a human understanding perspective.

**years_sell** represents the years the car has been sold.

```{r}
df$years_sell <-  2022 - df$year
summary(df$years_sell)
table(df$years_sell,useNA="always")
barplot(table(df$years_sell,useNA="always"), main = "years_sell barplot", col = "blue")
```

### price

```{r}
summary(df$price)
boxplot(df$price, main="price boxplot")
```

### mileage

```{r}
summary(df$mileage)
boxplot(df$mileage, main="mileage boxplot")
```

### mpg

```{r}
summary(df$mpg)
boxplot(df$mpg, main="mpg boxplot")
```

### tax

```{r}
summary(df$tax)
boxplot(df$tax, main="tax boxplot")
```

## Factors

### model

```{r}
df$model<-factor(paste0(trimws(df$manufacturer),"-",trimws(df$model)))

summary(df$model)
barplot(summary(df$model), main = "Model Barplot", col = "blue", horiz=TRUE)
```

### year

As you could imagine the distribution of years and years_sell is the same, but moved from right to left as a result of the subtract operation.
We have considered to join cars from year 1999 to 2009 because they are residual values, i.e. the amount of individuals per each one (year) is not representative enough.

```{r}
df[which(df$year<=2009),"year"] <- "2009 or before"

df$year <- factor(df$year)
df$year <- factor(df$year, labels = paste0("f.Year-",levels(df$year)))

summary(df$year)
barplot(summary(df$year), main = "year", col = "blue")
```

### transmission

```{r}
df$transmission<-factor(df$transmission)
df$transmission <- factor(df$transmission, levels = c("Manual","Semi-Auto","Automatic"),labels = paste0("f.Trans-",c("Manual","SemiAuto","Automatic")))

summary(df$transmission)
barplot(summary(df$transmission), main = "Transmission Barplot", col = "blue")
```

### fuelType

```{r}
df$fuelType<-factor(df$fuelType)
df$fuelType <- factor(df$fuelType, labels = paste0("f.Fuel-",levels(df$fuelType)))

summary(df$fuelType)
barplot(summary(df$fuelType), main = "FuelType Barplot", col = "blue")
```

### engineSize

We have considered to join cars with engineSize 4.2, 4.4, 4.7, 5, 5.2, 5.5, 6.2 and 6.6 because they are residual values, i.e. the amount of individuals per each one (engineSize) is not representative enough. 

```{r}
df[which(df$engineSize>=4.2),"engineSize"] <- "4.2 or more"

df$engineSize<-factor(df$engineSize)
df$engineSize <- factor(df$engineSize, labels = paste0("f.EngSize-",levels(df$engineSize)))

summary(df$engineSize)
barplot(summary(df$engineSize), main = "EngineSize Barplot", col = "blue")
```

### manufacturer

```{r}
df$manufacturer<-factor(df$manufacturer)
df$manufacturer <- factor(df$manufacturer, labels = levels(df$manufacturer))

summary(df$manufacturer)
barplot(summary(df$manufacturer), main = "Manufacturer Barplot", col = "blue")
```

# Data Quality Report

## Initialization of counts for missings, outliers and errors. 

```{r}

#######################################################
imis<-rep(0,nrow(df))  # rows - cars
jmis<-rep(0,ncol(df))  # columns - variables
######################################################
mis1<-countNA(df) #There are no missings at the beginning 

# Number of missings for the current set of cars
sum(mis1$mis_ind)
# Number of missings for the current set of variables
sum(mis1$mis_col)

#######################################################
iouts<-rep(0,nrow(df))  # rows - cars
jouts<-rep(0,ncol(df))  # columns - variables
######################################################

#######################################################
ierrs<-rep(0,nrow(df))  # rows - cars
jerrs<-rep(0,ncol(df))  # columns - variables
######################################################
```

As you can see from the previous stats there are no missings in the variables for the 
random data subset. 

## Errors

After the first analysis of the samples and the provided documentation of the dataset
we could say that the only visible errors are in the engineSize variable. 

Engine size equal to zero is considered as an electrical vehicle so this error
in the data needs to be considered and treated properly. 

```{r}
sel<-which(df$engineSize==0 & df$fuelType!="f.Fuel-Electric")
ierrs[sel]<-ierrs[sel]+1 
df[sel,"engineSize"]<-NA
selmiss <- sel
jerrs[9] <- length(sel)
```

## Univariate Outliers 

For each variable, we have executed calcQ in order to find the severe/extreme outliers (lower and upper). Then, we have recodified to/with NA the value of the variable of each individual with a value in the variable less than the under severe outlier or greater than the upper severe outlier to later apply imputation. 

### price

```{r}
Boxplot(df$price)
var_out<-calcQ(df$price)
abline(h=var_out$souts,col="red")
abline(h=var_out$souti,col="red")

# Outliers:
llout_price<-which((df$price<var_out$souti)|(df$price>var_out$souts))#souts abline
iouts[llout_price]<-iouts[llout_price]+1
jouts[3]<-length(llout_price)
```

### mileage

```{r}
Boxplot(df$mileage)
var_out<-calcQ(df$mileage)
abline(h=var_out$souts,col="red")
abline(h=var_out$souti,col="red")

# Outliers:
llout_mileage<-which((df$mileage<var_out$souti)|(df$mileage>var_out$souts))#souts abline
iouts[llout_mileage]<-iouts[llout_mileage]+1
jouts[5]<-length(llout_mileage)
df[llout_mileage,"mileage"]<-NA #llout
```

### tax

```{r}
Boxplot(df$tax)
var_out<-calcQ(df$tax)
abline(h=var_out$souts,col="red")
abline(h=var_out$souti,col="red")

# Outliers:
llout_tax<-which((df$tax<var_out$souti)|(df$tax>var_out$souts))#souts abline
iouts[llout_tax]<-iouts[llout_tax]+1
jouts[7]<-length(llout_tax)
df[llout_tax,"tax"]<-NA #llout
```

### mpg

```{r}
Boxplot(df$mpg)
var_out<-calcQ(df$mpg)
abline(h=var_out$souts,col="red")
abline(h=var_out$souti,col="red")

# Outliers:
llout_mpg<-which((df$mpg<var_out$souti)|(df$mpg>var_out$souts))#souts abline
iouts[llout_mpg]<-iouts[llout_mpg]+1
jouts[8]<-length(llout_mpg)
df[llout_mpg,"mpg"]<-NA #llout
```

### years_sell 

He have decided not to assign NA to years_sell because is a special variable with a low number of univariate outliers. 

```{r}
Boxplot(df$years_sell)
var_out<-calcQ(df$years_sell)
abline(h=var_out$souts,col="red")
abline(h=var_out$souti,col="red")

# Outliers:
llout_years_sell<-which((df$years_sell<var_out$souti)|(df$years_sell>var_out$souts))#souts abline
iouts[llout_years_sell]<-iouts[llout_years_sell]+1
jouts[11]<-length(llout_years_sell)
#df[llout_years_sell,"years_sell"]<-NA #llout
```

## Number of errors, missings and outliers for individual and variable

### Number of missing values of each variable

```{r}
jmis
```

### Number of errors per each variable

```{r}
jerrs
```

### Number of outilers per each variable

```{r}
outliers_ranking_sortlist <- sort.list(jouts, decreasing = TRUE)
for(j in outliers_ranking_sortlist) {
  if(!is.na(names(df)[j])) print(paste(names(df)[j], " : ", jouts[j]))
}
```

### Number of missing values individual

```{r}
sum(imis)
```

### Number of errors individual

```{r}
sum(ierrs)
```

### Number of outliers individual

```{r}
barplot(table(iouts), main = "Outliers per individual Barplot", col = "blue")
```

### New variable adding the total number missing values, outliers and errors

We have created a new variable to know the total missing values, outliers and errors per individual.

```{r}
df$totalMOE<- imis+iouts+ierrs
```

## Imputation

### Imputation of numeric variables

We do imputation in order to give a value to the missings (NA's). The (regularized) iterative PCA algorithm first consists imputing missing values with initial values such as the mean of the variable. 

```{r}
library(missMDA)

names(df)
vars_con<-names(df)[c(5,7,8)]
vars_dis<-names(df)[c(1:2, 4, 6, 9, 10)]
vars_res<-names(df)[c(3)]

summary(df[,vars_con])
res.impca<-imputePCA(df[,vars_con],ncp=2)
summary(res.impca)
```

We can notice a difference between the two plots, that means that the imputation has been/was correctly applied.

#### mileage

Plot comparison for mileage variable after imputation.

```{r, fig.align='center'}
par(mfrow = c(1,2))
hist(df$mileage)
hist(res.impca$completeObs[,"mileage"])

quantile(df$mileage,seq(0,1,0.1),na.rm=T)
round(quantile(res.impca$completeObs[,"mileage"],seq(0,1,0.1),na.rm=T),dig=1)
```

#### tax

Plot comparison for tax variable after imputation.

```{r, fig.align='center'}
par(mfrow=c(1,2))
hist(df$tax)
hist(res.impca$completeObs[,"tax"])

quantile(df$tax,seq(0,1,0.1),na.rm=T)
round(quantile(res.impca$completeObs[,"tax"],seq(0,1,0.1),na.rm=T),dig=1)
```

#### mpg

Plot comparison for mpg variable after imputation.

```{r, fig.align='center'}
par(mfrow = c(1,2))
hist(df$mpg)
hist(res.impca$completeObs[,"mpg"])

quantile(df$mpg,seq(0,1,0.1),na.rm=T)
round(quantile(res.impca$completeObs[,"mpg"],seq(0,1,0.1),na.rm=T),dig=1)
```

```{r}
df[,vars_con]<-res.impca$completeObs
```

### Imputation of factor variables

We do imputation in order to give a value to the missings (NA's). The (regularized) iterative MCA algorithm first consists in coding the categorical variables using the indicator matrix of dummy variables. Then, in the initialization step, missing values are imputed with initial values such as the proportion of the category for each category using the non-missing entries.

```{r}
summary(df[,vars_dis])
res.immca<-imputeMCA(df[,vars_dis],ncp=10)
summary(res.immca$completeObs)
```

We can notice a difference between the two plots, that means that the imputation has been/was correctly applied.

#### engineSize 

Plot comparison for engineSize variable. 

```{r}
par(mfrow=c(1,2))
barplot(table(df$engineSize),col="red")
barplot(table(res.immca$completeObs[,"engineSize"]),col="blue")
```

```{r}
df[ , vars_dis ]<-res.immca$completeObs 
sum(countNA(df)$mis_ind)==0
```

## Correlation of numeric variables with MOE

```{r}
cor(df[,c(3,5,7,8,11)], df$totalMOE)
```

As we can see years_sell is one of the variables with most correlation with total_MOE. This means
that as the time of a car being sold grows more tendency to have errors, outliers or/and missing
increase.

## Discretization

We do discretization in order to make it easier to understand the numeric variables.

### price variable

```{r}
quantile(df$price,seq(0,1,0.25),na.rm=TRUE)
quantile(df$price,seq(0,1,0.1),na.rm=TRUE)

df$aux_price<-factor(cut(df$price/1000,breaks=c(quantile(df$price,seq(0,1,0.25),na.rm=TRUE))/1000,include.lowest = T))
summary(df$aux_price)
tapply(df$price,df$aux_price,median)
levels(df$aux_price)<-paste("f.price-",levels(df$aux_price),sep="")
table(df$aux_price,useNA="always")
```

### mileage variable

```{r}
df$aux_mileage<-factor(cut(df$mileage,breaks=c(quantile(df$mileage,seq(0,1,0.25),na.rm=TRUE)),include.lowest = T ))
summary(df$aux_mileage)
tapply(df$mileage,df$aux_mileage,median)
levels(df$aux_mileage)<-paste("f.mileage-",levels(df$aux_mileage),sep="")
table(df$aux_mileage,useNA="always")
```

### tax variable

```{r}
quantile(df$tax,seq(0,1,0.25),na.rm=TRUE)

df$aux_tax<-factor(cut(df$tax,breaks=c(0, 125, 145, 580),include.lowest = T ))
summary(df$aux_tax)
tapply(df$tax,df$aux_tax,median)
levels(df$aux_tax)<-paste("f.tax-",levels(df$aux_tax),sep="")
table(df$aux_tax,useNA="always")
```

### mpg variable

```{r}
quantile(df$mpg,seq(0,1,0.25),na.rm=TRUE)
df$aux_mpg<-factor(cut(df$mpg,breaks=c(quantile(df$mpg,seq(0,1,0.25),na.rm=TRUE)),include.lowest = T ))
summary(df$aux_mpg)
tapply(df$mpg,df$aux_mpg,median)
levels(df$aux_mpg)<-paste("f.mpg-",levels(df$aux_mpg),sep="")
table(df$aux_mpg,useNA="always")
```

### years_sell variable

```{r}
df$aux_years_sell<-factor(cut(df$years_sell,breaks=c(quantile(df$years_sell,seq(0,1,0.25),na.rm=TRUE)),include.lowest = T ))
summary(df$aux_years_sell)
tapply(df$years_sell,df$aux_years_sell,median)
levels(df$aux_years_sell)<-paste("f.years_sell-",levels(df$aux_years_sell),sep="")
table(df$aux_years_sell,useNA="always")
```

## Definition of binary outcome: Audi

Create binary target, define lists of numeric and qualitative variables and save your raw base database

We have created a binary target to know if the car is Audi or not. We will use this variable later to do profiling with it. 

```{r}
# Binary Target: Audi?
df$Audi<-ifelse(df$manufacturer == "Audi",1,0)
df$Audi<-factor(df$Audi,labels=paste("Audi",c("No","Yes")))
summary(df$Audi)

# Pie
piepercent<-round(100*(table(df$Audi)/nrow(df)),dig=2); piepercent
pie(table(df$Audi),col=heat.colors(2),labels=paste(piepercent,"%"))
legend("topright", levels(df$Audi), cex = 0.8, fill = heat.colors(2))

# Bar Chart
barplot(table(df$Audi),main="Barplot Binary Outcome - Factor",col=c("red","green"))
```

## Multivariant outliers

We have executed Moutlier function in order to find the multivariant outliers. Then, we have created a new variable (df$mout) in order to distinguish/differentiate individuals that are multivariant outliers (they have a robust distance greater than the cutoff distance) and individuals that not. 

```{r}
library(chemometrics)
summary(df[,c(3, 5, 8, 11)])
mout<-Moutlier(df[,c(3, 5, 8, 11)],quantile = 0.9975, plot = TRUE)

length(which(mout$rd>mout$cutoff))
ll<-which(mout$rd>mout$cutoff)
Boxplot(mout$rd)
df[ll[1:3],c(3,5,8,11)]
df$mout <- 0
df$mout[ ll ]<-1
df$mout <- factor( df$mout, labels=c( "NoMOut","YesMOut"))
table(df$mout)

par(mfrow=c(1,1))
plot(mout$md,mout$rd, type="n")
text(mout$md,mout$rd,labels=rownames(df[,vars_con]))
abline(h=mout$cutoff,col="red",lwd=2)
abline(v=mout$cutoff,col="red",lwd=2)

abline(h=mout$cutof^2,col="red",lwd=2,lty=2)
abline(v=mout$cutoff^2,col="red",lwd=2,lty=2)
```

## Profiling

```{r}
library(FactoMineR)
summary(df$price)
res.condes<-condes(df,3)
res.condes$quanti  # Global association to numeric variables
res.condes$quali # Global association to factors
res.condes$category  # Partial association to significative levels in factors
```

As we can see in the output condes$quanti, price variable is related with totalMOE, mpg, mileage and years_sell variables because their p-values are less than 0.05.
More concretely, against more price less totalMOE, less mileage, less years_sell and less mpg. 

As we can see in the output condes$quali, model variable has a high relation, i.e. certain models have high and/or low prices.

Regarding the output of condes$category, we can feature cars with model Audi-R8 which on average cost 56033.34832£ than baseline price, cars with model Audi-Q8 which on average cost 43576.84832£ more than baseline price and cars with model BMW-X7 which on average cost 42413.20546£ more than baseline price. 
On the other hand, we can feature cars with model Mercedes-CLC Class which on average cost 23029.15168£ less than baseline price, cars with model Mercedes-SLK which on average cost 20110.85168£ less than baseline price and finally cars with model VW-Up which on average cost 20805.93577£ less than baseline price. 

```{r}
summary(df$Audi)
res.catdes<-catdes(df,18)
res.catdes$quanti.var  # Global association to numeric variables
res.catdes$quanti # Partial association of numeric variables to levels of outcome factor
res.catdes$test.chi2 # Global association to factors
res.catdes$category  # Partial association to significative levels in factors
```

As we can see in the output catdes$quanti.var, we can feature that µ_mpgAudiNo, µ_mpgAudiYes and µ_mpg are not the same because the p-value is less than 0.05.

As we can see in the output catdes$quanti, we can feature that Audi cars on average consume more, because on average they have less mpg. 

As we can see in the output catdes$test.chi2, we can feature that Audi variable and model variable are not independent because the p-value is less than 0.05. Also, Audi variable and engineSize variable are not independent for the same reason.

As we can see in the output catdes$category, we can feature that VW, Mercedes and BMW cars are overrepresented in Audi No sample. Also, we can feature that engineSize 1.4, 2, 4 and 2.5 are overrepresented in Audi Yes sample and engineSize 1, 1.5, 1.2, 1.3, 2.1 are underrepresented in Audi Yes sample.
